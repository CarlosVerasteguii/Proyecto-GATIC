# PERF P0 After (After Changes) — 2026-01-30

Scope: **Fase 1 = P0 (Quick Wins)**. Este archivo contiene **MEDICION DESPUES** + confirmaciones (EXPLAIN).

## 1) Setup (repro)

```powershell
docker compose -f gatic/compose.yaml up -d
docker compose -f gatic/compose.yaml exec -T laravel.test php artisan migrate:fresh --seed
```

App: `http://localhost:8080` (APP_PORT=8080).

Usuarios seeded:
- Admin: `admin@gatic.local` / `password`
- Lector: `lector@gatic.local` / `password`

## 2) Metodologia

Misma que baseline (`PERF_P0_BASELINE.md`):
- `curl.exe` (`time_starttransfer` = TTFB, `time_total` = total)
- `p50/p90` = nearest-rank (n=10 salvo donde se indique)
- Livewire: POST real a `/livewire/update` con `wire:snapshot` + `data-csrf`

## 3) Resultados — HTTP (cURL)

### /login
- Cold (n=1, despues de `docker compose -f gatic/compose.yaml restart laravel.test`):
  - TTFB: **3715ms**
  - Total: **3726ms**
- Warm (n=10):
  - TTFB p50/p90: **178ms / 1475ms**
  - Total p50/p90: **178ms / 1480ms**

### /inventory/products (Admin vs Lector; interleaved; n=10 por rol)

Admin:
- TTFB p50/p90: **315ms / 1924ms**
- Total p50/p90: **316ms / 1931ms**

Lector:
- TTFB p50/p90: **298ms / 2000ms**
- Total p50/p90: **299ms / 2005ms**

### /pending-tasks (Admin; n=10)
- TTFB p50/p90: **274ms / 1860ms**
- Total p50/p90: **274ms / 1867ms**

## 4) Resultados — Livewire

### InventorySearch — ya NO hay requests por tecla

Cambio UX: ahora la busqueda se ejecuta por `submitSearch` (Enter/boton), no por `wire:model.live`.

Medicion (n=10): **1 request por busqueda** (call `submitSearch` con `search=Dell`)
- TTFB p50/p90: **212ms / 1758ms**
- Total p50/p90: **213ms / 1765ms**

### PendingTaskShow — enterProcessMode + render diferido (wire:init)

Interaccion ahora = 2 requests:
1) `enterProcessMode` (claim lock + shell rapido)
2) `initProcessModeUi` (render diferido de tabla pesada)

Medicion (n=10):
- `enterProcessMode` Total p50/p90: **309ms / 1756ms**
- `initProcessModeUi` Total p50/p90: **237ms / 1925ms**
- `enter + init` Total p50/p90: **573ms / 2396ms**

## 5) DB — SQL real (captura via query log)

### 5.1 SearchInventory::execute("Dell") (sin leading wildcard)

```sql
select * from `assets` where `asset_tag` = ? and `assets`.`deleted_at` is null limit 1
-- bindings: ["DELL"]

select * from `assets` where `serial` = ? and `assets`.`deleted_at` is null order by `serial` asc
-- bindings: ["Dell"]

select * from `products` where name like ? escape '\\' and `products`.`deleted_at` is null order by `name` asc limit 20
-- bindings: ["Dell%"]

select * from `assets` where (serial like ? escape '\\' or asset_tag like ? escape '\\') and `assets`.`deleted_at` is null order by `serial` asc limit 20
-- bindings: ["Dell%","Dell%"]
```

### 5.2 ProductsIndex (simplePaginate: sin COUNT)

```sql
select `products`.*, `categories_for_counts`.`is_serialized` as `category_is_serialized`,
  (select count(*) from `assets`
    where `assets`.`product_id` = `products`.`id`
      and `assets`.`status` != ?
      and `categories_for_counts`.`is_serialized` = ?
      and `assets`.`deleted_at` is null) as `assets_total`,
  (select count(*) from `assets`
    where `assets`.`product_id` = `products`.`id`
      and `assets`.`status` in (?, ?, ?)
      and `categories_for_counts`.`is_serialized` = ?
      and `assets`.`deleted_at` is null) as `assets_unavailable`
from `products`
left join `categories` as `categories_for_counts`
  on `categories_for_counts`.`id` = `products`.`category_id`
 and `categories_for_counts`.`deleted_at` is null
where `products`.`deleted_at` is null
order by `products`.`name` asc
limit 16 offset 0
-- bindings: ["Retirado", true, "Asignado", "Prestado", "Pendiente de Retiro", true]
```

## 6) DB — EXPLAIN ANALYZE (confirmar uso de indice)

### 6.1 products.name LIKE "Dell%" (usa indice `products_name_index`)

```text
*************************** 1. row ***************************
EXPLAIN: -> Limit: 20 row(s)  (cost=0.71 rows=1) (actual time=0.0141..0.0141 rows=0 loops=1)
    -> Filter: (products.deleted_at is null)  (cost=0.71 rows=1) (actual time=0.0136..0.0136 rows=0 loops=1)
        -> Index range scan on products using products_name_index over ('Dell' <= name <= 'Dell????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????'), with index condition: (products.`name` like 'Dell%' escape '\\')  (cost=0.71 rows=1) (actual time=0.0129..0.0129 rows=0 loops=1)
```

### 6.2 assets.serial exact (usa indice nuevo `assets_serial_index`)

```text
*************************** 1. row ***************************
EXPLAIN: -> Filter: (assets.deleted_at is null)  (cost=0.27 rows=0.2) (actual time=0.887..0.889 rows=1 loops=1)
    -> Index lookup on assets using assets_serial_index (serial='SN-DEMO-001')  (cost=0.27 rows=1) (actual time=0.032..0.0338 rows=1 loops=1)
```

### 6.3 assets serial/tag LIKE "Dell%" (index merge por OR: serial + asset_tag)

```text
*************************** 1. row ***************************
EXPLAIN: -> Limit: 20 row(s)  (cost=1.61 rows=2) (actual time=0.115..0.115 rows=0 loops=1)
    -> Sort: assets.`serial`, limit input to 20 row(s) per chunk  (cost=1.61 rows=2) (actual time=0.115..0.115 rows=0 loops=1)
        -> Filter: (((assets.`serial` like 'Dell%' escape '\\') or (assets.asset_tag like 'Dell%' escape '\\')) and (assets.deleted_at is null))  (cost=1.61 rows=2) (actual time=0.111..0.111 rows=0 loops=1)
            -> Sort-deduplicate by row ID  (cost=1.61 rows=2) (actual time=0.11..0.11 rows=0 loops=1)
                -> Index range scan on assets using assets_serial_index over ('Dell' <= serial <= 'Dell????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????')  (cost=0.36 rows=1) (actual time=0.0962..0.0962 rows=0 loops=1)
                -> Index range scan on assets using assets_asset_tag_unique over ('Dell' <= asset_tag <= 'Dell????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????')  (cost=0.36 rows=1) (actual time=0.00462..0.00462 rows=0 loops=1)
```

### 6.4 ProductsIndex (select) — COUNT eliminado (simplePaginate)

```text
*************************** 1. row ***************************
EXPLAIN: -> Limit: 16 row(s)  (cost=0.7 rows=1) (actual time=0.0698..0.0703 rows=1 loops=1)
    -> Nested loop left join  (cost=0.7 rows=1) (actual time=0.0694..0.0698 rows=1 loops=1)
        -> Sort: products.`name`  (cost=0.35 rows=1) (actual time=0.0584..0.0585 rows=1 loops=1)
            -> Filter: (products.deleted_at is null)  (cost=0.35 rows=1) (actual time=0.0252..0.0292 rows=1 loops=1)
                -> Table scan on products  (cost=0.35 rows=1) (actual time=0.0238..0.0276 rows=1 loops=1)
        -> Filter: (categories_for_counts.deleted_at is null)  (cost=0.35 rows=1) (actual time=0.00997..0.0101 rows=1 loops=1)
            -> Single-row index lookup on categories_for_counts using PRIMARY (id=products.category_id)  (cost=0.35 rows=1) (actual time=0.00958..0.00964 rows=1 loops=1)
-> Select #2 (subquery in projection; dependent)
    -> Aggregate: count(0)  (cost=0.85 rows=1) (actual time=0.0499..0.0499 rows=1 loops=1)
        -> Filter: ((assets.product_id = products.id) and (assets.`status` <> 'Retirado') and (categories_for_counts.is_serialized = 1) and (assets.deleted_at is null))  (cost=0.75 rows=1) (actual time=0.0439..0.0476 rows=4 loops=1)
            -> Table scan on assets  (cost=0.75 rows=5) (actual time=0.0416..0.0443 rows=5 loops=1)
-> Select #3 (subquery in projection; dependent)
    -> Aggregate: count(0)  (cost=0.85 rows=1) (actual time=0.0212..0.0212 rows=1 loops=1)
        -> Filter: ((assets.product_id = products.id) and (assets.`status` in ('Asignado','Prestado','Pendiente de Retiro')) and (categories_for_counts.is_serialized = 1) and (assets.deleted_at is null))  (cost=0.75 rows=1) (actual time=0.0176..0.0203 rows=3 loops=1)
            -> Table scan on assets  (cost=0.75 rows=5) (actual time=0.0155..0.0172 rows=5 loops=1)
```

Notes:
- Aunque el planner sigue eligiendo scans en tablas chicas (demo), aqui se valida el objetivo P0:
  - busquedas ahora son **index-friendly** (sin leading wildcard) y `EXPLAIN ANALYZE` muestra **Index range/lookup** donde aplica.
  - `paginate()` -> `simplePaginate()` elimina el COUNT extra.

